<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>// Kaige geneted code starts
const int MAXP = 23;
const int NONE = -1;
const int MAXL = 12;
const int MAXSO = 1;
const int MAXPRE = 2;
const int MAXSUC = 2;

typedef int[-1,65535] id_t;

typedef struct {
    int32_t x;
    int32_t y;
}ST_DPOINT;

typedef struct {
    double x;
    double y;
}ST_CPOINT;

typedef struct {
    ST_DPOINT ends[2];
}ST_DLINE;

typedef struct {
    ST_DPOINT points[MAXP];
    bool dashLine;
}ST_BOUND;

typedef struct {
    id_t ID;
    ST_BOUND left;
    ST_BOUND right;
    id_t predecessor[MAXPRE];
    id_t successor[MAXSUC];
    id_t adjLeft;
    bool dirLeft;
    id_t adjRight;
    bool dirRight;
}ST_LANE;

typedef struct {
    bool collide; // collision
    bool outside; // outside road
    bool reach;   // reach the goal
}ST_DETECTION;

typedef struct {
    ST_CPOINT position;
    double velocity;
    double orientation;
    double acceleration;
    double yawRate;
}ST_CSTATE;

typedef struct {
    ST_DPOINT position;
    int16_t velocity;
    int16_t orientation;
    int16_t acceleration;
    int16_t yawRate;
    ST_DETECTION detection;
}ST_DSTATE;

typedef struct {
    hybrid clock x;
    hybrid clock y;
    hybrid clock velocity;
    hybrid clock orientation;
    hybrid clock acceleration;
    hybrid clock yawRate;
}ST_VARIABLES;

typedef struct {
    ST_DPOINT center;
    int16_t width;
    int16_t length;
    int16_t orientation;
}ST_RECTANGLE;

typedef struct {
    int maxVelocity;
    int minVelocity;
    int maxOrientation;
    int minOrientation;
}ST_RULES;

typedef struct {
    ST_DPOINT goal;
}ST_PLANNING;
const ST_BOUND leftLane1 = {{{-13141, -3504}, {-11442, -2731}, {-9650, -1910}, {-9580, -1880}, {-8905, -1589}, {-8225, -1334}, {-8117, -1294}, {-6705, -775}, {-6630, -750}, {-5919, -520}, {-5833, -496}, {-5194, -320}, {-5171, -313}, {-4696, -191}, {-4591, -164}, {-4184, -87}, {-4022, -57}, {-3281, 36}, {-2167, 154}, {-1130, 207}, {-1044, 205}, {210, 175}, {NONE, NONE}}, false};
const ST_BOUND rightLane1 = {{{-13030, -3824}, {-11317, -2987}, {-9519, -2216}, {-9448, -2185}, {-8774, -1908}, {-8103, -1632}, {-8007, -1592}, {-6599, -1050}, {-6541, -1027}, {-5830, -793}, {-5757, -769}, {-5119, -590}, {-5095, -583}, {-4629, -453}, {-4544, -438}, {-4132, -366}, {-3987, -348}, {-3244, -258}, {-2132, -178}, {-1112, -123}, {-1052, -119}, {178, -192}, {NONE, NONE}}, false};
const ST_LANE lane1 = {50195, leftLane1, rightLane1, {NONE, NONE}, {50209, 50211}, 50197, false, NONE, false};

const ST_BOUND leftLane2 = {{{210, 175}, {-1130, 207}, {-1167, 205}, {-2068, 160}, {-2153, 156}, {-3210, 44}, {-3246, 41}, {-4022, -57}, {-4206, -92}, {-4591, -164}, {-5113, -298}, {-5171, -313}, {-5919, -520}, {-6646, -755}, {-6705, -775}, {-8171, -1314}, {-8225, -1334}, {-8905, -1589}, {-8951, -1608}, {-9650, -1910}, {-9866, -2009}, {-11442, -2731}, {-13141, -3504}}, false};
const ST_BOUND rightLane2 = {{{57, 577}, {-1133, 570}, {-1185, 570}, {-2085, 500}, {-2193, 487}, {-3243, 360}, {-3294, 352}, {-4067, 233}, {-4262, 202}, {-4658, 104}, {-5183, -25}, {-5254, -47}, {-5995, -279}, {-6726, -508}, {-6792, -532}, {-8266, -1058}, {-8316, -1075}, {-9001, -1316}, {-9067, -1340}, {-9767, -1633}, {-9995, -1729}, {-11565, -2472}, {-13257, -3272}}, false};
const ST_LANE lane2 = {50197, leftLane2, rightLane2, {50207, 50213}, {NONE, NONE}, 50195, false, NONE, false};

const ST_BOUND leftLane3 = {{{2889, -121}, {4179, -389}, {5329, -628}, {5377, -638}, {6356, -848}, {7205, -971}, {7229, -972}, {8067, -1031}, {8931, -1032}, {9002, -1033}, {10039, -1007}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}}, false};
const ST_BOUND rightLane3 = {{{2806, -524}, {4088, -827}, {5223, -1087}, {5278, -1100}, {6276, -1295}, {7155, -1396}, {7199, -1402}, {8054, -1430}, {8930, -1435}, {9020, -1431}, {10061, -1385}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}}, false};
const ST_LANE lane3 = {50199, leftLane3, rightLane3, {50211, 50217}, {NONE, NONE}, 50201, false, NONE, false};

const ST_BOUND leftLane4 = {{{10039, -1007}, {9002, -1033}, {8846, -1032}, {8067, -1031}, {7205, -971}, {6356, -848}, {5329, -628}, {2889, -121}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}}, false};
const ST_BOUND rightLane4 = {{{10028, -649}, {8995, -669}, {8846, -672}, {8079, -649}, {7249, -561}, {6433, -415}, {5400, -230}, {2999, 251}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}}, false};
const ST_LANE lane4 = {50201, leftLane4, rightLane4, {NONE, NONE}, {50213, 50215}, 50199, false, NONE, false};

const ST_BOUND leftLane5 = {{{1687, 1123}, {1638, 1472}, {1539, 1859}, {1321, 2512}, {1164, 2976}, {1004, 3455}, {413, 5228}, {-14, 6569}, {-616, 8203}, {-1128, 9520}, {-1606, 10849}, {-2199, 12364}, {-2800, 13814}, {-3550, 15548}, {-4207, 17035}, {-4684, 18185}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}}, false};
const ST_BOUND rightLane5 = {{{2020, 1207}, {1991, 1477}, {1877, 2051}, {1718, 2706}, {1437, 3585}, {829, 5464}, {393, 6727}, {-145, 8290}, {-711, 9736}, {-1253, 11071}, {-1896, 12616}, {-2490, 14146}, {-3267, 15822}, {-3847, 17200}, {-4112, 17824}, {-4365, 18415}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}}, false};
const ST_LANE lane5 = {50203, leftLane5, rightLane5, {50209, 50215}, {NONE, NONE}, 50205, false, NONE, false};

const ST_BOUND leftLane6 = {{{-4684, 18185}, {-4207, 17035}, {-3550, 15548}, {-2800, 13814}, {-2199, 12364}, {-1606, 10849}, {-1128, 9520}, {-616, 8203}, {-14, 6569}, {413, 5228}, {1004, 3455}, {1164, 2976}, {1321, 2512}, {1539, 1859}, {1638, 1472}, {1687, 1123}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}}, false};
const ST_BOUND rightLane6 = {{{-5011, 18039}, {-4533, 16916}, {-3890, 15365}, {-3142, 13680}, {-2546, 12241}, {-1938, 10743}, {-1454, 9407}, {-972, 8094}, {-379, 6461}, {57, 5134}, {649, 3357}, {1053, 2324}, {1230, 1768}, {1267, 1593}, {1273, 1419}, {1240, 1180}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}}, false};
const ST_LANE lane6 = {50205, leftLane6, rightLane6, {NONE, NONE}, {50207, 50217}, 50203, false, NONE, false};

const ST_BOUND leftLane7 = {{{1687, 1123}, {1683, 1017}, {1677, 843}, {1675, 780}, {1667, 645}, {1648, 527}, {1626, 454}, {1586, 395}, {1500, 304}, {1420, 260}, {1325, 229}, {1212, 207}, {1114, 195}, {1026, 189}, {906, 185}, {731, 180}, {671, 178}, {518, 173}, {435, 170}, {290, 173}, {210, 175}, {NONE, NONE}, {NONE, NONE}}, false};
const ST_BOUND rightLane7 = {{{1240, 1180}, {1183, 1035}, {1183, 1035}, {1183, 1035}, {1090, 895}, {1071, 865}, {1071, 865}, {1071, 865}, {1071, 865}, {1071, 865}, {935, 767}, {888, 733}, {888, 733}, {888, 733}, {888, 733}, {656, 642}, {653, 641}, {504, 616}, {369, 595}, {299, 584}, {57, 577}, {NONE, NONE}, {NONE, NONE}}, false};
const ST_LANE lane7 = {50207, leftLane7, rightLane7, {50205, NONE}, {50197, NONE}, 50209, false, NONE, false};

const ST_BOUND leftLane8 = {{{210, 175}, {435, 170}, {731, 180}, {825, 183}, {1006, 189}, {1114, 195}, {1212, 207}, {1325, 229}, {1420, 260}, {1500, 304}, {1586, 395}, {1626, 454}, {1648, 527}, {1675, 780}, {1687, 1123}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}}, false};
const ST_BOUND rightLane8 = {{{178, -192}, {422, -200}, {717, -211}, {838, -215}, {1019, -206}, {1183, -178}, {1294, -156}, {1405, -106}, {1567, -29}, {1690, 71}, {1816, 183}, {1880, 272}, {1942, 382}, {2015, 753}, {2020, 1207}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}}, false};
const ST_LANE lane8 = {50209, leftLane8, rightLane8, {50195, NONE}, {50203, NONE}, 50207, false, NONE, false};

const ST_BOUND leftLane9 = {{{210, 175}, {955, 163}, {1073, 152}, {1459, 117}, {1895, 69}, {2889, -121}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}}, false};
const ST_BOUND rightLane9 = {{{178, -192}, {926, -245}, {1036, -253}, {1408, -300}, {1847, -354}, {2806, -524}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}}, false};
const ST_LANE lane9 = {50211, leftLane9, rightLane9, {50195, NONE}, {50199, NONE}, 50213, false, NONE, false};

const ST_BOUND leftLane10 = {{{2889, -121}, {2304, -7}, {1932, 64}, {1768, 83}, {1459, 117}, {1040, 155}, {955, 163}, {541, 170}, {210, 175}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}}, false};
const ST_BOUND rightLane10 = {{{2999, 251}, {2374, 351}, {1987, 412}, {1809, 440}, {1493, 470}, {1072, 510}, {985, 518}, {547, 554}, {57, 577}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}}, false};
const ST_LANE lane10 = {50213, leftLane10, rightLane10, {50201, NONE}, {50197, NONE}, 50211, false, NONE, false};

const ST_BOUND leftLane11 = {{{2889, -121}, {2015, 67}, {1945, 93}, {1877, 140}, {1783, 243}, {1728, 367}, {1691, 504}, {1680, 644}, {1687, 1123}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}}, false};
const ST_BOUND rightLane11 = {{{2999, 251}, {2745, 304}, {2381, 386}, {2293, 413}, {2201, 478}, {2133, 575}, {2095, 681}, {2047, 963}, {2020, 1207}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}}, false};
const ST_LANE lane11 = {50215, leftLane11, rightLane11, {50201, NONE}, {50203, NONE}, 50217, false, NONE, false};

const ST_BOUND leftLane12 = {{{1687, 1123}, {1682, 786}, {1680, 644}, {1680, 644}, {1690, 517}, {1691, 504}, {1721, 392}, {1728, 367}, {1758, 298}, {1783, 243}, {1783, 243}, {1875, 141}, {1877, 140}, {1907, 119}, {1945, 93}, {1946, 93}, {2015, 67}, {2054, 59}, {2242, 18}, {2889, -121}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}}, false};
const ST_BOUND rightLane12 = {{{1240, 1180}, {1213, 793}, {1214, 638}, {1220, 588}, {1233, 482}, {1255, 393}, {1285, 274}, {1337, 171}, {1362, 121}, {1452, -18}, {1486, -53}, {1568, -135}, {1644, -189}, {1681, -214}, {1762, -257}, {1808, -281}, {1861, -303}, {1966, -346}, {2151, -401}, {2806, -524}, {NONE, NONE}, {NONE, NONE}, {NONE, NONE}}, false};
const ST_LANE lane12 = {50217, leftLane12, rightLane12, {50205, NONE}, {50199, NONE}, 50215, false, NONE, false};

const ST_LANE laneNet[MAXL] = {lane1, lane2, lane3, lane4, lane5, lane6, lane7, lane8, lane9, lane10, lane11, lane12};

const bool staticObsExists = false;
const ST_RECTANGLE staticObs[MAXSO] = {{{NONE, NONE}, NONE, NONE, NONE}};

const ST_PLANNING planning = {{1251, 262}};

//Kaige generated code ends

typedef struct {
    uint16_t time;
    double acceleration;
    double yawRate;
}ST_PAIR;

const int P = 1;
const uint8_t MAXTIME = 10;
const uint8_t pLen0 = 5;
const ST_PAIR policy0[pLen0] = {{0, 0.0, 0.0}, {2, 0.0, -0.4}, {4, 0.0, 0.4}, {6, 0.0, 0.0}, {MAXTIME, 0.0, 0.0}};
broadcast chan chooseEgo, chooseObs, begin, update;

ST_DSTATE dStateEgo;
ST_VARIABLES vars;      // continuous variables
hybrid clock D;         /// "cost" of distance used in strategy optimization
clock time;             // global time

double i2d(const int i) {
    const double SCALE = 100.0; // scale from int to double: 100 = 1.0
    double v = i/SCALE;
    return v;
}

int d2i(const double i) {
    const double SCALE = 100.0; // scale from int to double: 100 = 1.0
    int v = fint(i*SCALE);
    return v;
}

double getDisP2P(const ST_DPOINT &amp;p1, const ST_DPOINT &amp;p2) {
    double distance = 0.0;
    double rx1 = i2d(p1.x), ry1 = i2d(p1.y);
    double rx2 = i2d(p2.x), ry2 = i2d(p2.y);
    distance = sqrt(pow(rx1 - rx2, 2) + pow(ry1 - ry2, 2));

    return distance;
}

double getDisP2L(const ST_DPOINT &amp;p, const ST_DLINE &amp;l) {
    // do nothing for now
    double distance = 0.0;

    return distance;
}

const double THRESHOLD = 2.0;
bool collision(const ST_RECTANGLE &amp;obj, ST_RECTANGLE staticObs) {
    double distance;
    distance = getDisP2P(obj.center, staticObs.center);
    if(distance &lt;= THRESHOLD) {
        return true;
    }
    return false;
}

bool outOfRoad(const ST_RECTANGLE &amp;obj) {
    if(obj.center.x &lt; lane1.left.points[0].x || obj.center.x &gt; lane1.left.points[1].x)
        return true;
    if(obj.center.y &lt; lane1.right.points[0].y || obj.center.y &gt; lane3.left.points[0].y)   
        return true;

    return false;  
}

void initCon(ST_VARIABLES &amp;vars, const ST_CSTATE &amp;initCS) {
    vars.x = initCS.position.x;
    vars.y = initCS.position.y;
    vars.velocity = initCS.velocity;
    vars.orientation = initCS.orientation;
    vars.acceleration = initCS.acceleration;
    vars.yawRate = initCS.yawRate;

    time = 0;
    if(dStateEgo.detection.reach) 
        D = 0; // only reset the reward function when reaching the goal
    if(dStateEgo.detection.collide || dStateEgo.detection.outside)
        D = D + 100; // punish the ego when it collides or goes outside the road    
}

void initDis(ST_DSTATE &amp;dState, const ST_CSTATE &amp;initCS) {
    dState.position.x = d2i(initCS.position.x);
    dState.position.y = d2i(initCS.position.y);
    dState.velocity = d2i(initCS.velocity);
    dState.orientation = d2i(initCS.orientation);
    dState.acceleration = d2i(initCS.acceleration);
    dState.yawRate = d2i(initCS.yawRate);

    dState.detection.collide = false;
    dState.detection.outside = false;
    dState.detection.reach = false;
}


void updateDis(ST_DSTATE &amp;dState, ST_RECTANGLE &amp;shape) {
    // real numbers of the current state
    double rVelocity = 0.0, vx = 0.0, vy = 0.0;
    double rOrientation = 0.0, rAcceleration = 0.0, rYawRate = 0.0;
    // int/real numbers of velocity on X and Y axes
    int dVx = 0, dVy = 0;
    uint8_t i = 0;

    // update discrete velocity and orientation
    dState.velocity = dState.velocity + dState.acceleration * P;
    dState.orientation = dState.orientation + dState.yawRate * P;
    // conversion to real numbers
    rVelocity = i2d(dState.velocity);
    rOrientation = i2d(dState.orientation);
    rAcceleration = i2d(dState.acceleration);
    rYawRate = i2d(dState.yawRate);
    // velocity projection
    vx = rVelocity*cos(rOrientation);
    vy = rVelocity*sin(rOrientation);
    dVx = d2i(vx);
    dVy = d2i(vy);
    // update other discrete varaibles
    dState.position.x = dState.position.x + dVx * P;
    dState.position.y = dState.position.y + dVy * P;
    shape.center.x = dState.position.x;
    shape.center.y = dState.position.y;
    shape.orientation = dState.orientation;
    dState.detection.outside = outOfRoad(shape);
    dState.detection.reach = (getDisP2P(shape.center, planning.goal) &lt;= THRESHOLD);
    if(staticObsExists) {
        for(i = 0; i &lt; MAXSO; i++) {
            dState.detection.collide |= collision(shape, staticObs[i]);
        }
    }
}

void updateCon(ST_VARIABLES &amp;vars) {
    vars.acceleration = i2d(dStateEgo.acceleration);
    vars.yawRate = i2d(dStateEgo.yawRate);
}


</declaration>
	<template>
		<name x="5" y="5">MovingObs</name>
		<parameter>const id_t ID, const ST_CSTATE &amp;initCS, const ST_RECTANGLE &amp;shape</parameter>
		<declaration>// Place local declarations here.
ST_VARIABLES vars;  // continuous variables
ST_DSTATE dState;   // discrete state
uint8_t pc = 0;     // policy counter
uint8_t tc = 0;     // time counter
ST_RECTANGLE self;

void initialize() {
    pc = 0;
    tc = 0;
    initCon(vars,initCS);
    initDis(dState,initCS);
    self = shape;
}

void decisionMaking() {
    if(pc &lt; pLen0 &amp;&amp; tc == policy0[pc].time) {
        vars.acceleration = policy0[pc].acceleration;
        vars.yawRate = policy0[pc].yawRate;
        dState.acceleration = d2i(policy0[pc].acceleration);
        dState.yawRate = d2i(policy0[pc].yawRate);
        pc++;
    }
    else if(pc &lt; pLen0) {
        tc++;
    }
    else if(pc &gt;= pLen0 - 1) {
        vars.velocity = 0;
        vars.acceleration = 0;
        vars.yawRate = 0;
        dState.velocity = 0;
        dState.acceleration = 0;
        dState.yawRate = 0;
    }
}









</declaration>
		<location id="id0" x="-102" y="-34">
			<name x="-76" y="-34">Move</name>
			<label kind="invariant" x="-255" y="-17">vars.x' == vars.velocity*cos(vars.orientation) &amp;&amp;
vars.y' == vars.velocity*sin(vars.orientation) &amp;&amp;
vars.velocity' == vars.acceleration &amp;&amp;
vars.orientation' == vars.yawRate &amp;&amp;
vars.yawRate' == 0 &amp;&amp;
vars.acceleration' == 0</label>
		</location>
		<init ref="id0"/>
		<transition id="id1" controllable="false">
			<source ref="id0"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-161" y="-119">update?</label>
			<label kind="assignment" x="-161" y="-102">updateDis(dState,self)</label>
			<nail x="-136" y="-102"/>
			<nail x="-68" y="-102"/>
		</transition>
		<transition id="id2" controllable="false">
			<source ref="id0"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-246" y="-68">begin?</label>
			<label kind="assignment" x="-246" y="-51">initialize()</label>
			<nail x="-170" y="-68"/>
			<nail x="-170" y="-34"/>
		</transition>
		<transition id="id3" controllable="false">
			<source ref="id0"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-34" y="-68">chooseObs?</label>
			<label kind="assignment" x="-42" y="-51">decisionMaking()</label>
			<nail x="-34" y="-34"/>
			<nail x="-34" y="-68"/>
		</transition>
	</template>
	<template>
		<name>Controller</name>
		<parameter>const id_t ID, const ST_CSTATE &amp;initCS, const ST_RECTANGLE &amp;shape, const ST_RULES &amp;rules</parameter>
		<declaration>typedef int[0,0] BRAKE_t;    // 1 gear of brake force
typedef int[0,0] PUSH_t;     // 1 gear of push force
typedef int[0,1] TURN_t;     // 2 speeds of turning 

const int8_t Brake[3] = {d2i(-0.1), d2i(-0.2), d2i(-0.3)};
const int8_t Push[3] = {d2i(0.1), d2i(0.2), d2i(0.3)};
const int8_t Turn[2] = {d2i(0.4), d2i(-0.4)};
const bool CONSTANTSPEED = true;

ST_RECTANGLE self;

void initialize() {
    initDis(dStateEgo,initCS);
    self = shape;
}

void opConst() {
    dStateEgo.acceleration = 0;
    vars.acceleration = 0;
}

void opAcc(int gear) {
    dStateEgo.acceleration = Push[gear];
    vars.acceleration = i2d(Push[gear]);
}

void opBrake(int gear) {
    dStateEgo.acceleration = Brake[gear];
    vars.acceleration = i2d(Brake[gear]);
}

/*int nextX = 0;
int nextY = 0;
int nextRate = 0;
int nextOrientation = 0;*/
void opTurn(int dir) {
    int nr = Turn[dir];
    int no = dStateEgo.orientation;
    double rVelocity = i2d(dStateEgo.velocity);
    double rOrientation = i2d(no);
    double vx = rVelocity*cos(rOrientation);
    double vy = rVelocity*sin(rOrientation);
    int nx = self.center.x + d2i(vx) * P;
    int ny = self.center.y + d2i(vy) * P;

    /*nextX = nx;
    nextY = ny;
    nextRate = nr;
    nextOrientation = no;*/

    dStateEgo.yawRate = Turn[dir];
    vars.yawRate = i2d(Turn[dir]);
}

void keep() {
    dStateEgo.yawRate = 0;
    vars.yawRate = 0.0;
}

bool canAcc(int gear) {
    int nextAcc = Push[gear];
    if(!CONSTANTSPEED &amp;&amp; dStateEgo.velocity + P*nextAcc &lt;= rules.maxVelocity) 
        return true;
    return false;
}

bool canDec(int gear) {
    int nextDec = Brake[gear];
    if(!CONSTANTSPEED &amp;&amp; dStateEgo.velocity + P*nextDec &gt;= rules.minVelocity) 
        return true;
    return false;
}

bool canTurn(int dir) {
    int nextRate = Turn[dir];
    int nextOrientation = dStateEgo.orientation + P*nextRate;
    ST_RECTANGLE nextShape = shape;
    double rVelocity = i2d(dStateEgo.velocity);
    double rOrientation = i2d(nextOrientation);
    double vx = rVelocity*cos(rOrientation);
    double vy = rVelocity*sin(rOrientation);

    nextShape.center.x = self.center.x + d2i(vx) * P;
    nextShape.center.y = self.center.y + d2i(vy) * P;
    nextShape.orientation = nextOrientation;

    if(nextOrientation &gt;= rules.minOrientation &amp;&amp; nextOrientation &lt;= rules.maxOrientation &amp;&amp; !outOfRoad(nextShape)) 
        return true;
    return false;
}</declaration>
		<location id="id4" x="-340" y="-136">
			<name x="-433" y="-161">Turn_Const</name>
			<label kind="comments" x="-34" y="-51">One cannot turn and 
acc or brake 
simutaneously.</label>
		</location>
		<location id="id5" x="-68" y="136">
			<name x="-187" y="136">Straight_Dec</name>
		</location>
		<location id="id6" x="-68" y="-136">
			<name x="-51" y="-170">Straight_Acc</name>
		</location>
		<location id="id7" x="-204" y="0">
			<name x="-289" y="-17">Choose</name>
			<committed/>
		</location>
		<location id="id8" x="-340" y="136">
			<name x="-476" y="161">Straight_Const</name>
		</location>
		<init ref="id8"/>
		<transition id="id9" controllable="false">
			<source ref="id5"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="-280" y="187">begin?</label>
			<label kind="assignment" x="-195" y="187">initialize()</label>
			<nail x="-68" y="204"/>
			<nail x="-340" y="204"/>
		</transition>
		<transition id="id10" controllable="false">
			<source ref="id6"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="-424" y="-221">begin?</label>
			<label kind="assignment" x="-424" y="-204">initialize()</label>
			<nail x="-68" y="-204"/>
			<nail x="-442" y="-204"/>
			<nail x="-442" y="0"/>
		</transition>
		<transition id="id11" controllable="false">
			<source ref="id4"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="-433" y="-34">begin?</label>
			<label kind="assignment" x="-433" y="-17">initialize()</label>
			<nail x="-408" y="-136"/>
			<nail x="-408" y="0"/>
		</transition>
		<transition id="id12" controllable="false">
			<source ref="id8"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="-306" y="144">update?</label>
			<label kind="assignment" x="-306" y="161">updateDis(dStateEgo,self)</label>
			<nail x="-331" y="170"/>
			<nail x="-306" y="170"/>
		</transition>
		<transition id="id13" controllable="false">
			<source ref="id5"/>
			<target ref="id5"/>
			<label kind="synchronisation" x="-25" y="93">update?</label>
			<label kind="assignment" x="-25" y="119">updateDis(dStateEgo,self)</label>
			<nail x="-34" y="102"/>
			<nail x="-34" y="136"/>
		</transition>
		<transition id="id14" controllable="false">
			<source ref="id6"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="-42" y="-144">update?</label>
			<label kind="assignment" x="-42" y="-127">updateDis(dStateEgo,self)</label>
			<nail x="-34" y="-136"/>
			<nail x="-34" y="-102"/>
		</transition>
		<transition id="id15" controllable="false">
			<source ref="id4"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-314" y="-187">update?</label>
			<label kind="assignment" x="-314" y="-170">updateDis(dStateEgo,self)</label>
			<nail x="-306" y="-170"/>
			<nail x="-340" y="-170"/>
		</transition>
		<transition id="id16">
			<source ref="id4"/>
			<target ref="id7"/>
			<label kind="synchronisation" x="-357" y="-68">chooseEgo?</label>
			<label kind="assignment" x="-357" y="-51">keep()</label>
			<label kind="comments" x="-34" y="25">Keeps moving with 
this angle</label>
			<nail x="-340" y="-68"/>
		</transition>
		<transition id="id17" controllable="false">
			<source ref="id8"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="-467" y="102">begin?</label>
			<label kind="assignment" x="-467" y="119">initialize()</label>
			<nail x="-374" y="102"/>
			<nail x="-374" y="127"/>
		</transition>
		<transition id="id18">
			<source ref="id7"/>
			<target ref="id4"/>
			<label kind="select" x="-263" y="-93">d:TURN_t</label>
			<label kind="guard" x="-263" y="-76">canTurn(d)</label>
			<label kind="assignment" x="-263" y="-59">opTurn(d)</label>
			<nail x="-272" y="-136"/>
		</transition>
		<transition id="id19">
			<source ref="id5"/>
			<target ref="id7"/>
			<label kind="synchronisation" x="-195" y="102">chooseEgo?</label>
			<nail x="-136" y="136"/>
		</transition>
		<transition id="id20">
			<source ref="id7"/>
			<target ref="id5"/>
			<label kind="select" x="-144" y="17">f:BRAKE_t</label>
			<label kind="guard" x="-144" y="34">canDec(f)</label>
			<label kind="assignment" x="-144" y="51">opBrake(f)</label>
			<nail x="-68" y="68"/>
		</transition>
		<transition id="id21">
			<source ref="id6"/>
			<target ref="id7"/>
			<label kind="synchronisation" x="-195" y="-119">chooseEgo?</label>
			<nail x="-136" y="-136"/>
		</transition>
		<transition id="id22">
			<source ref="id7"/>
			<target ref="id6"/>
			<label kind="select" x="-136" y="-76">f:PUSH_t</label>
			<label kind="guard" x="-136" y="-59">canAcc(f)</label>
			<label kind="assignment" x="-136" y="-42">opAcc(f)</label>
			<nail x="-68" y="-68"/>
		</transition>
		<transition id="id23">
			<source ref="id7"/>
			<target ref="id8"/>
			<label kind="assignment" x="-340" y="51">opConst()</label>
			<nail x="-340" y="68"/>
		</transition>
		<transition id="id24">
			<source ref="id8"/>
			<target ref="id7"/>
			<label kind="synchronisation" x="-314" y="102">chooseEgo?</label>
			<nail x="-272" y="136"/>
		</transition>
	</template>
	<template>
		<name>Decisions</name>
		<declaration>clock timer;
int counter = 0;</declaration>
		<location id="id25" x="102" y="68">
			<name x="110" y="42">Idle</name>
			<label kind="invariant" x="85" y="85">timer&lt;=P</label>
		</location>
		<location id="id26" x="102" y="-34">
			<name x="92" y="-68">Done</name>
			<urgent/>
		</location>
		<location id="id27" x="-68" y="-34">
			<name x="-78" y="-68">ObsGo</name>
			<urgent/>
		</location>
		<location id="id28" x="-204" y="-34">
			<name x="-214" y="-68">EgoGo</name>
			<urgent/>
		</location>
		<location id="id29" x="-340" y="-34">
			<name x="-350" y="-68">Start</name>
			<urgent/>
		</location>
		<init ref="id29"/>
		<transition id="id30" controllable="false">
			<source ref="id25"/>
			<target ref="id28"/>
			<label kind="guard" x="-348" y="51">counter==MAXTIME</label>
			<label kind="synchronisation" x="-348" y="68">begin!</label>
			<label kind="assignment" x="-348" y="85">timer=0,counter=0</label>
			<nail x="68" y="102"/>
			<nail x="-340" y="102"/>
			<nail x="-340" y="0"/>
		</transition>
		<transition id="id31" controllable="false">
			<source ref="id29"/>
			<target ref="id28"/>
			<label kind="synchronisation" x="-280" y="-59">begin!</label>
		</transition>
		<transition id="id32" controllable="false">
			<source ref="id25"/>
			<target ref="id28"/>
			<label kind="guard" x="-170" y="0">timer==P&amp;&amp;
counter!=MAXTIME</label>
			<label kind="synchronisation" x="-170" y="42">update!</label>
			<label kind="assignment" x="-102" y="42">timer=0,counter++</label>
			<nail x="-204" y="68"/>
		</transition>
		<transition id="id33" controllable="false">
			<source ref="id26"/>
			<target ref="id25"/>
			<label kind="assignment" x="59" y="-8">timer=0</label>
		</transition>
		<transition id="id34" controllable="false">
			<source ref="id27"/>
			<target ref="id26"/>
			<label kind="synchronisation" x="-34" y="-59">chooseObs!</label>
		</transition>
		<transition id="id35" controllable="false">
			<source ref="id28"/>
			<target ref="id27"/>
			<label kind="synchronisation" x="-170" y="-59">chooseEgo!</label>
		</transition>
	</template>
	<template>
		<name>Dynamics</name>
		<parameter>const id_t ID, const ST_CSTATE &amp;initCS</parameter>
		<declaration>// Place local declarations here.</declaration>
		<location id="id36" x="0" y="0">
			<name x="-59" y="-8">Move</name>
			<label kind="invariant" x="-161" y="17">vars.x' == vars.velocity*cos(vars.orientation) &amp;&amp;
vars.y' == vars.velocity*sin(vars.orientation) &amp;&amp;
vars.velocity' == vars.acceleration &amp;&amp;
vars.orientation' == vars.yawRate &amp;&amp;
vars.yawRate' == 0 &amp;&amp;
vars.acceleration' == 0 &amp;&amp;
D' == getDisP2P(dStateEgo.position, planning.goal) 
      - dStateEgo.detection.reach * 100 
      + dStateEgo.detection.collide * 50 
      + dStateEgo.detection.outside * 50</label>
		</location>
		<init ref="id36"/>
		<transition id="id37" controllable="false">
			<source ref="id36"/>
			<target ref="id36"/>
			<label kind="synchronisation" x="68" y="-68">update?</label>
			<label kind="assignment" x="68" y="-51">updateCon(vars)</label>
			<nail x="68" y="-68"/>
			<nail x="68" y="-34"/>
		</transition>
		<transition id="id38" controllable="false">
			<source ref="id36"/>
			<target ref="id36"/>
			<label kind="synchronisation" x="-161" y="-68">begin?</label>
			<label kind="assignment" x="-161" y="-51">initCon(vars,initCS)</label>
			<nail x="-68" y="-34"/>
			<nail x="-68" y="-68"/>
		</transition>
	</template>
	<system>// Place template instantiations here.
//const ST_DSTATE initDS1 = {{225, 350}, 230, 0, 0, 0};
const ST_CSTATE initCS1 = {{2.25, 3.50}, 2.30, 0.0, 0.0, 0.0};
const ST_RECTANGLE shapeObs1 = {{225, 350}, 200, 450, 0};
obs1 = MovingObs(1, initCS1, shapeObs1);

const ST_CSTATE initEgo = {{2.25, 7.0}, 3.0, 0.0, 0.0, 0.0};
const ST_RECTANGLE shapeEgo = {{225, 700}, 200, 450, 0};
const ST_RULES rules = {400, 0, 157, -157}; 
egoController = Controller(1, initEgo, shapeEgo, rules);
egoDynamics = Dynamics(1, initEgo);

// List one or more processes to be composed into a system.
system Decisions, egoController, egoDynamics, obs1;
//system Decisions, obs1;
</system>
	<queries>
		<query>
			<formula>simulate [&lt;=30] { obs1.vars.x, obs1.vars.y }</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=30] { obs1.vars.velocity, obs1.vars.orientation, obs1.vars.yawRate, obs1.vars.acceleration }</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=30] { obs1.vars.acceleration, i2d(obs1.dState.acceleration) }</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=30] { obs1.vars.yawRate, i2d(obs1.dState.yawRate) }</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=30] { obs1.vars.velocity, i2d(obs1.dState.velocity) }</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=30] { obs1.vars.orientation, i2d(obs1.dState.orientation) }</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=30] { obs1.vars.x, i2d(obs1.dState.position.x), obs1.vars.y, i2d(obs1.dState.position.y) }</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=30;100] { sqrt(pow(obs1.vars.x-i2d(obs1.dState.position.x),2) + pow(obs1.vars.y-i2d(obs1.dState.position.y),2)) }</formula>
			<comment/>
		</query>
		<query>
			<formula/>
			<comment>//</comment>
		</query>
		<query>
			<formula>simulate [&lt;=30;100] { vars.x-i2d(dStateEgo.position.x), vars.y-i2d(dStateEgo.position.y) }</formula>
			<comment/>
		</query>
		<query>
			<formula/>
			<comment>//</comment>
		</query>
		<query>
			<formula>A[] !dStateEgo.detection.collide</formula>
			<comment/>
		</query>
		<query>
			<formula>A[] !dStateEgo.detection.outside</formula>
			<comment/>
		</query>
		<query>
			<formula/>
			<comment>//</comment>
		</query>
		<query>
			<formula>strategy safe = control:A[] !dStateEgo.detection.collide &amp;&amp; !dStateEgo.detection.outside</formula>
			<comment/>
		</query>
		<query>
			<formula>saveStrategy("/Users/rgu01/Library/CloudStorage/OneDrive-Mälardalensuniversitet/Documents/Postdoc/Conferences/2024/ISoLA/models/safe.out", safe)</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=30] { vars.acceleration, i2d(dStateEgo.acceleration), vars.velocity, i2d(dStateEgo.velocity) } under safe</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=30] { vars.yawRate, i2d(dStateEgo.orientation), vars.orientation } under safe</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=30] { vars.x, i2d(dStateEgo.position.x), vars.y, i2d(dStateEgo.position.y) } under safe</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=30;100] { vars.x-i2d(dStateEgo.position.x), vars.y-i2d(dStateEgo.position.y) } under safe</formula>
			<comment/>
		</query>
		<query>
			<formula>A[] !dStateEgo.detection.collide &amp;&amp; !dStateEgo.detection.outside under safe</formula>
			<comment/>
		</query>
		<query>
			<formula>Pr[&lt;=10](&lt;&gt;dStateEgo.detection.reach) under safe</formula>
			<comment/>
		</query>
		<query>
			<formula>E[&lt;=100;100](min:getDisP2P(dStateEgo.position, staticObs[0].center)) under safe</formula>
			<comment/>
		</query>
		<query>
			<formula>E[&lt;=100;100](min:getDisP2P(dStateEgo.position, planning.goal)) under safe</formula>
			<comment/>
		</query>
		<query>
			<formula>//</formula>
			<comment/>
		</query>
		<query>
			<formula>strategy reachSafe = minE(D) [&lt;=MAXTIME] {egoController.location, dStateEgo.position.x, dStateEgo.position.y,
					  dStateEgo.velocity, dStateEgo.orientation, dStateEgo.acceleration,
					  dStateEgo.yawRate}-&gt;{}: &lt;&gt; time&gt;=MAXTIME under safe</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=30;100] { getDisP2P(dStateEgo.position, planning.goal) } under safe</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=30;100] { getDisP2P(dStateEgo.position, planning.goal) } under reachSafe</formula>
			<comment/>
		</query>
		<query>
			<formula>Pr[&lt;=10](&lt;&gt; dStateEgo.detection.reach) under reachSafe</formula>
			<comment/>
		</query>
		<query>
			<formula>E[&lt;=100;100](min:getDisP2P(dStateEgo.position, staticObs[0].center)) under reachSafe</formula>
			<comment/>
		</query>
		<query>
			<formula>E[&lt;=100;100](min:getDisP2P(dStateEgo.position, planning.goal)) under reachSafe</formula>
			<comment/>
		</query>
		<query>
			<formula/>
			<comment>//</comment>
		</query>
		<query>
			<formula>strategy reach = minE(D) [&lt;=MAXTIME] {egoController.location, dStateEgo.position.x, dStateEgo.position.y,
					  dStateEgo.velocity, dStateEgo.orientation, dStateEgo.acceleration,
					  dStateEgo.yawRate}-&gt;{}: &lt;&gt; time&gt;=MAXTIME</formula>
			<comment/>
		</query>
		<query>
			<formula>saveStrategy("/home/ron/Projects/Commonroad/uppaal/reach.out", reach)</formula>
			<comment/>
		</query>
		<query>
			<formula>A&lt;&gt; dStateEgo.detection.reach under reach</formula>
			<comment/>
		</query>
		<query>
			<formula>A[] !dStateEgo.detection.collide &amp;&amp; !dStateEgo.detection.outside under reach</formula>
			<comment/>
		</query>
		<query>
			<formula>simulate [&lt;=MAXTIME] { vars.x, i2d(dStateEgo.position.x), vars.y, i2d(dStateEgo.position.y) } under reach</formula>
			<comment/>
		</query>
		<query>
			<formula>E[&lt;=100;100](min:getDisP2P(dStateEgo.position, staticObs[0].center)) under reach</formula>
			<comment/>
		</query>
		<query>
			<formula>E[&lt;=100;100](min:getDisP2P(dStateEgo.position, planning.goal)) under reach</formula>
			<comment/>
		</query>
	</queries>
</nta>
