<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>// Generated scenario starts
const int P = 1;
const uint8_t MAXTIME = 10;
const int MAXP = 201;
const int NONE = -1;
const int MAXL = 2;
const int MAXSO = 1;
const int MAXDO = 1;
const int MAXTP = 0;
const int MAXPRE = 1;
const int MAXSUC = 1;
const double SCALE = 100.0;
const int THRESHOLD = 200;
const double TIMESTEPSIZE = 0.1;

typedef int[-1,65535] id_t;

typedef struct {
    int32_t x;
    int32_t y;
}ST_DPOINT;

typedef struct {
    double x;
    double y;
}ST_CPOINT;

typedef struct {
    ST_DPOINT ends[2];
}ST_DLINE;

typedef struct {
    ST_DPOINT points[MAXP];
    bool dashLine;
}ST_BOUND;

typedef struct {
    id_t ID;
    ST_BOUND left;
    ST_BOUND right;
    id_t predecessor[MAXPRE];
    id_t successor[MAXSUC];
    id_t adjLeft;
    bool dirLeft;
    id_t adjRight;
    bool dirRight;
}ST_LANE;

typedef struct {
    bool collide; // collision
    bool outside; // outside road
    bool reach;   // reach the goal
}ST_DETECTION;

typedef struct {
    ST_CPOINT position;
    double velocity;
    double orientation;
    double acceleration;
    double yawRate;
}ST_CSTATE;

typedef struct {
    ST_DPOINT position;
    int16_t velocity;
    int16_t orientation;
    int16_t acceleration;
    int16_t yawRate;
    ST_DETECTION detection;
}ST_DSTATE;

typedef struct {
    hybrid clock x;
    hybrid clock y;
    hybrid clock velocity;
    hybrid clock orientation;
    hybrid clock acceleration;
    hybrid clock yawRate;
}ST_VARIABLES;

typedef struct {
    ST_DPOINT center;
    int16_t width;
    int16_t length;
    int16_t orientation;
}ST_RECTANGLE;

typedef struct {
    int maxVelocity;
    int minVelocity;
    int maxOrientation;
    int minOrientation;
}ST_RULES;

typedef struct {
    ST_DPOINT goal;
}ST_PLANNING;

typedef struct {
    int32_t time;
    ST_CSTATE cState;
}ST_PAIR;
const ST_BOUND leftLane1 = {{{0, 0}, {100, 0}, {200, 0}, {300, 0}, {400, 0}, {500, 1}, {600, 1}, {700, 2}, {799, 2}, {899, 3}, {999, 4}, {1099, 5}, {1199, 6}, {1299, 8}, {1399, 9}, {1499, 10}, {1599, 12}, {1699, 14}, {1799, 16}, {1899, 18}, {1999, 20}, {2099, 22}, {2199, 24}, {2299, 27}, {2399, 29}, {2499, 32}, {2599, 35}, {2699, 38}, {2799, 41}, {2899, 44}, {2999, 47}, {3099, 51}, {3199, 54}, {3299, 58}, {3399, 62}, {3499, 66}, {3599, 70}, {3698, 74}, {3798, 78}, {3898, 83}, {3998, 87}, {4098, 92}, {4198, 97}, {4298, 102}, {4398, 107}, {4498, 113}, {4597, 118}, {4697, 124}, {4797, 130}, {4897, 136}, {4997, 142}, {5096, 148}, {5196, 154}, {5296, 161}, {5396, 167}, {5496, 174}, {5595, 181}, {5695, 188}, {5795, 196}, {5895, 203}, {5994, 211}, {6094, 219}, {6194, 227}, {6293, 235}, {6393, 243}, {6493, 251}, {6592, 260}, {6692, 269}, {6791, 277}, {6891, 287}, {6991, 296}, {7090, 305}, {7190, 315}, {7289, 325}, {7389, 334}, {7488, 345}, {7588, 355}, {7687, 365}, {7787, 376}, {7886, 387}, {7985, 398}, {8085, 409}, {8184, 420}, {8283, 432}, {8383, 443}, {8482, 455}, {8581, 467}, {8681, 480}, {8780, 492}, {8879, 505}, {8978, 517}, {9077, 530}, {9177, 544}, {9276, 557}, {9375, 570}, {9474, 584}, {9573, 598}, {9672, 612}, {9771, 627}, {9870, 641}, {9969, 656}, {10067, 671}, {10166, 686}, {10265, 701}, {10364, 717}, {10463, 732}, {10561, 748}, {10660, 765}, {10759, 781}, {10857, 797}, {10956, 814}, {11055, 831}, {11153, 848}, {11252, 866}, {11350, 883}, {11448, 901}, {11547, 919}, {11645, 937}, {11743, 956}, {11842, 974}, {11940, 993}, {12038, 1012}, {12136, 1031}, {12234, 1051}, {12332, 1071}, {12430, 1090}, {12528, 1111}, {12626, 1131}, {12724, 1152}, {12822, 1172}, {12919, 1193}, {13017, 1215}, {13115, 1236}, {13212, 1258}, {13310, 1280}, {13408, 1302}, {13505, 1324}, {13602, 1347}, {13700, 1370}, {13797, 1393}, {13894, 1416}, {13991, 1440}, {14089, 1464}, {14186, 1488}, {14283, 1512}, {14380, 1536}, {14477, 1561}, {14573, 1586}, {14670, 1611}, {14767, 1637}, {14864, 1662}, {14960, 1688}, {15057, 1715}, {15153, 1741}, {15249, 1768}, {15346, 1795}, {15442, 1822}, {15538, 1849}, {15634, 1877}, {15730, 1905}, {15826, 1933}, {15922, 1961}, {16018, 1990}, {16114, 2019}, {16209, 2048}, {16305, 2077}, {16400, 2107}, {16496, 2137}, {16591, 2167}, {16686, 2197}, {16782, 2228}, {16877, 2259}, {16972, 2290}, {17067, 2322}, {17162, 2353}, {17256, 2385}, {17351, 2417}, {17446, 2450}, {17540, 2483}, {17634, 2516}, {17729, 2549}, {17823, 2582}, {17917, 2616}, {18011, 2650}, {18105, 2685}, {18199, 2719}, {18293, 2754}, {18386, 2789}, {18480, 2825}, {18573, 2860}, {18666, 2896}, {18760, 2932}, {18853, 2969}, {18946, 3006}, {19039, 3043}, {19131, 3080}, {19224, 3117}, {19317, 3155}, {19409, 3193}, {19502, 3232}, {19594, 3270}}, false};
const ST_BOUND rightLane1 = {{{0, -325}, {100, -325}, {200, -324}, {300, -324}, {401, -324}, {501, -323}, {602, -323}, {702, -322}, {802, -322}, {903, -321}, {1003, -320}, {1103, -319}, {1204, -318}, {1304, -316}, {1404, -315}, {1505, -314}, {1605, -312}, {1705, -310}, {1806, -308}, {1906, -306}, {2006, -304}, {2107, -302}, {2207, -300}, {2308, -297}, {2408, -295}, {2508, -292}, {2609, -289}, {2709, -286}, {2809, -283}, {2910, -280}, {3010, -277}, {3111, -273}, {3211, -270}, {3311, -266}, {3412, -262}, {3512, -258}, {3612, -254}, {3713, -250}, {3813, -245}, {3913, -241}, {4014, -236}, {4114, -231}, {4214, -226}, {4315, -221}, {4415, -216}, {4515, -211}, {4616, -205}, {4716, -200}, {4816, -194}, {4917, -188}, {5017, -182}, {5117, -175}, {5217, -169}, {5318, -162}, {5418, -156}, {5518, -149}, {5619, -142}, {5719, -135}, {5819, -127}, {5919, -120}, {6020, -112}, {6120, -104}, {6220, -96}, {6320, -88}, {6420, -80}, {6521, -72}, {6621, -63}, {6721, -54}, {6821, -45}, {6921, -36}, {7021, -27}, {7121, -17}, {7221, -8}, {7322, 1}, {7422, 11}, {7522, 21}, {7622, 32}, {7722, 42}, {7822, 53}, {7922, 64}, {8022, 75}, {8122, 86}, {8222, 97}, {8321, 109}, {8421, 121}, {8521, 133}, {8621, 145}, {8721, 157}, {8821, 170}, {8921, 182}, {9020, 195}, {9120, 208}, {9220, 221}, {9320, 235}, {9419, 249}, {9519, 262}, {9619, 276}, {9718, 291}, {9818, 305}, {9918, 320}, {10017, 335}, {10117, 350}, {10216, 365}, {10316, 380}, {10415, 396}, {10514, 412}, {10614, 428}, {10713, 444}, {10812, 460}, {10912, 477}, {11011, 494}, {11110, 511}, {11209, 528}, {11309, 546}, {11408, 563}, {11507, 581}, {11606, 599}, {11705, 618}, {11804, 636}, {11903, 655}, {12002, 674}, {12101, 693}, {12199, 713}, {12298, 732}, {12397, 752}, {12496, 772}, {12594, 792}, {12693, 813}, {12792, 834}, {12890, 855}, {12989, 876}, {13087, 897}, {13185, 919}, {13284, 941}, {13382, 963}, {13480, 985}, {13579, 1008}, {13677, 1031}, {13775, 1054}, {13873, 1077}, {13971, 1100}, {14069, 1124}, {14167, 1148}, {14265, 1172}, {14362, 1197}, {14460, 1222}, {14558, 1246}, {14655, 1272}, {14753, 1297}, {14850, 1323}, {14948, 1349}, {15045, 1375}, {15142, 1401}, {15240, 1428}, {15337, 1455}, {15434, 1482}, {15531, 1509}, {15628, 1537}, {15725, 1565}, {15822, 1593}, {15919, 1621}, {16015, 1650}, {16112, 1679}, {16208, 1708}, {16305, 1737}, {16401, 1767}, {16498, 1797}, {16594, 1827}, {16690, 1857}, {16786, 1888}, {16882, 1919}, {16978, 1950}, {17074, 1982}, {17170, 2013}, {17265, 2045}, {17361, 2078}, {17457, 2110}, {17552, 2143}, {17647, 2176}, {17743, 2209}, {17838, 2243}, {17933, 2277}, {18028, 2311}, {18123, 2345}, {18217, 2380}, {18312, 2415}, {18407, 2450}, {18501, 2485}, {18596, 2521}, {18690, 2557}, {18784, 2593}, {18878, 2630}, {18972, 2667}, {19066, 2704}, {19160, 2741}, {19254, 2779}, {19347, 2817}, {19441, 2855}, {19534, 2893}, {19627, 2932}, {19719, 2971}}, false};
const ST_LANE lane1 = {1000, leftLane1, rightLane1, {NONE}, {NONE}, 1001, false, NONE, false};

const ST_BOUND leftLane2 = {{{19594, 3270}, {19502, 3232}, {19409, 3193}, {19317, 3155}, {19224, 3117}, {19131, 3080}, {19039, 3043}, {18946, 3006}, {18853, 2969}, {18760, 2932}, {18666, 2896}, {18573, 2860}, {18480, 2825}, {18386, 2789}, {18293, 2754}, {18199, 2719}, {18105, 2685}, {18011, 2650}, {17917, 2616}, {17823, 2582}, {17729, 2549}, {17634, 2516}, {17540, 2483}, {17446, 2450}, {17351, 2417}, {17256, 2385}, {17162, 2353}, {17067, 2322}, {16972, 2290}, {16877, 2259}, {16782, 2228}, {16686, 2197}, {16591, 2167}, {16496, 2137}, {16400, 2107}, {16305, 2077}, {16209, 2048}, {16114, 2019}, {16018, 1990}, {15922, 1961}, {15826, 1933}, {15730, 1905}, {15634, 1877}, {15538, 1849}, {15442, 1822}, {15346, 1795}, {15249, 1768}, {15153, 1741}, {15057, 1715}, {14960, 1688}, {14864, 1662}, {14767, 1637}, {14670, 1611}, {14573, 1586}, {14477, 1561}, {14380, 1536}, {14283, 1512}, {14186, 1488}, {14089, 1464}, {13991, 1440}, {13894, 1416}, {13797, 1393}, {13700, 1370}, {13602, 1347}, {13505, 1324}, {13408, 1302}, {13310, 1280}, {13212, 1258}, {13115, 1236}, {13017, 1215}, {12919, 1193}, {12822, 1172}, {12724, 1152}, {12626, 1131}, {12528, 1111}, {12430, 1090}, {12332, 1071}, {12234, 1051}, {12136, 1031}, {12038, 1012}, {11940, 993}, {11842, 974}, {11743, 956}, {11645, 937}, {11547, 919}, {11448, 901}, {11350, 883}, {11252, 866}, {11153, 848}, {11055, 831}, {10956, 814}, {10857, 797}, {10759, 781}, {10660, 765}, {10561, 748}, {10463, 732}, {10364, 717}, {10265, 701}, {10166, 686}, {10067, 671}, {9969, 656}, {9870, 641}, {9771, 627}, {9672, 612}, {9573, 598}, {9474, 584}, {9375, 570}, {9276, 557}, {9177, 544}, {9077, 530}, {8978, 517}, {8879, 505}, {8780, 492}, {8681, 480}, {8581, 467}, {8482, 455}, {8383, 443}, {8283, 432}, {8184, 420}, {8085, 409}, {7985, 398}, {7886, 387}, {7787, 376}, {7687, 365}, {7588, 355}, {7488, 345}, {7389, 334}, {7289, 325}, {7190, 315}, {7090, 305}, {6991, 296}, {6891, 287}, {6791, 277}, {6692, 269}, {6592, 260}, {6493, 251}, {6393, 243}, {6293, 235}, {6194, 227}, {6094, 219}, {5994, 211}, {5895, 203}, {5795, 196}, {5695, 188}, {5595, 181}, {5496, 174}, {5396, 167}, {5296, 161}, {5196, 154}, {5096, 148}, {4997, 142}, {4897, 136}, {4797, 130}, {4697, 124}, {4597, 118}, {4498, 113}, {4398, 107}, {4298, 102}, {4198, 97}, {4098, 92}, {3998, 87}, {3898, 83}, {3798, 78}, {3698, 74}, {3599, 70}, {3499, 66}, {3399, 62}, {3299, 58}, {3199, 54}, {3099, 51}, {2999, 47}, {2899, 44}, {2799, 41}, {2699, 38}, {2599, 35}, {2499, 32}, {2399, 29}, {2299, 27}, {2199, 24}, {2099, 22}, {1999, 20}, {1899, 18}, {1799, 16}, {1699, 14}, {1599, 12}, {1499, 10}, {1399, 9}, {1299, 8}, {1199, 6}, {1099, 5}, {999, 4}, {899, 3}, {799, 2}, {700, 2}, {600, 1}, {500, 1}, {400, 0}, {300, 0}, {200, 0}, {100, 0}, {0, 0}}, false};
const ST_BOUND rightLane2 = {{{19468, 3570}, {19377, 3532}, {19285, 3494}, {19194, 3456}, {19102, 3419}, {19010, 3381}, {18918, 3345}, {18826, 3308}, {18734, 3271}, {18642, 3235}, {18550, 3199}, {18457, 3164}, {18365, 3129}, {18272, 3093}, {18179, 3059}, {18086, 3024}, {17993, 2990}, {17900, 2956}, {17807, 2922}, {17714, 2889}, {17621, 2855}, {17527, 2822}, {17434, 2790}, {17340, 2757}, {17246, 2725}, {17152, 2693}, {17059, 2661}, {16965, 2630}, {16870, 2599}, {16776, 2568}, {16682, 2537}, {16588, 2507}, {16493, 2477}, {16399, 2447}, {16304, 2417}, {16209, 2388}, {16115, 2359}, {16020, 2330}, {15925, 2301}, {15830, 2273}, {15735, 2245}, {15640, 2217}, {15544, 2189}, {15449, 2162}, {15354, 2135}, {15258, 2108}, {15163, 2081}, {15067, 2054}, {14972, 2028}, {14876, 2002}, {14780, 1977}, {14684, 1951}, {14588, 1926}, {14492, 1901}, {14396, 1876}, {14300, 1852}, {14204, 1827}, {14108, 1803}, {14011, 1779}, {13915, 1756}, {13819, 1732}, {13722, 1709}, {13625, 1686}, {13529, 1664}, {13432, 1641}, {13336, 1619}, {13239, 1597}, {13142, 1575}, {13045, 1554}, {12948, 1532}, {12851, 1511}, {12754, 1490}, {12657, 1470}, {12560, 1449}, {12463, 1429}, {12365, 1409}, {12268, 1389}, {12171, 1370}, {12073, 1350}, {11976, 1331}, {11879, 1312}, {11781, 1293}, {11684, 1275}, {11586, 1257}, {11488, 1239}, {11391, 1221}, {11293, 1203}, {11195, 1186}, {11097, 1168}, {10999, 1151}, {10902, 1135}, {10804, 1118}, {10706, 1101}, {10608, 1085}, {10510, 1069}, {10412, 1053}, {10313, 1038}, {10215, 1022}, {10117, 1007}, {10019, 992}, {9921, 977}, {9822, 963}, {9724, 948}, {9626, 934}, {9527, 920}, {9429, 906}, {9331, 892}, {9232, 879}, {9134, 866}, {9035, 853}, {8937, 840}, {8838, 827}, {8739, 814}, {8641, 802}, {8542, 790}, {8444, 778}, {8345, 766}, {8246, 755}, {8147, 743}, {8049, 732}, {7950, 721}, {7851, 710}, {7752, 699}, {7653, 689}, {7554, 678}, {7455, 668}, {7357, 658}, {7258, 648}, {7159, 638}, {7060, 629}, {6961, 619}, {6862, 610}, {6763, 601}, {6663, 592}, {6564, 584}, {6465, 575}, {6366, 567}, {6267, 559}, {6168, 550}, {6069, 543}, {5970, 535}, {5870, 527}, {5771, 520}, {5672, 513}, {5573, 505}, {5473, 499}, {5374, 492}, {5275, 485}, {5176, 479}, {5076, 472}, {4977, 466}, {4878, 460}, {4778, 454}, {4679, 448}, {4580, 443}, {4480, 437}, {4381, 432}, {4281, 427}, {4182, 422}, {4083, 417}, {3983, 412}, {3884, 407}, {3784, 403}, {3685, 399}, {3585, 394}, {3486, 390}, {3386, 386}, {3287, 383}, {3187, 379}, {3088, 375}, {2988, 372}, {2889, 369}, {2789, 365}, {2690, 362}, {2590, 359}, {2491, 357}, {2391, 354}, {2291, 351}, {2192, 349}, {2092, 347}, {1993, 345}, {1893, 343}, {1793, 341}, {1694, 339}, {1594, 337}, {1495, 335}, {1395, 334}, {1295, 333}, {1196, 331}, {1096, 330}, {996, 329}, {897, 328}, {797, 327}, {698, 327}, {598, 326}, {498, 326}, {399, 325}, {299, 325}, {199, 325}, {100, 325}, {0, 325}}, false};
const ST_LANE lane2 = {1001, leftLane2, rightLane2, {NONE}, {NONE}, 1000, false, NONE, false};

const ST_LANE laneNet[MAXL] = {lane1, lane2};

const bool staticObsExists = true;
const ST_RECTANGLE staticObs[MAXSO] = {{{5994, 48}, 350, 600, 7}};

const ST_PLANNING planning = {{8780, 330}};


// Generated scenario ends

broadcast chan chooseEgo, chooseObs, begin, update;

ST_DSTATE dStateEgo;       // discrete variables
ST_VARIABLES varsEgo;      // continuous variables
ST_RECTANGLE shapeEgo;     // shape of ego vehicle
hybrid clock D;            /// "cost" of distance used in strategy optimization
clock time;                // global time

double i2d(const int32_t i) {
    double v = i/SCALE;
    return v;
}

int32_t d2i(const double i) {
    int32_t v = fint(i*SCALE);
    return v;
}

double mTimeStep(const double value) {
    return value*TIMESTEPSIZE;
}

int32_t getDisP2P(const ST_DPOINT &amp;p1, const ST_DPOINT &amp;p2) {
    double distance = 0.0;
    double rx1 = i2d(p1.x), ry1 = i2d(p1.y);
    double rx2 = i2d(p2.x), ry2 = i2d(p2.y);
    distance = sqrt(pow(rx1 - rx2, 2) + pow(ry1 - ry2, 2));

    return d2i(distance);
}

// Function to calculate the corner points of a rectangle
void calculateCornerPoints(ST_RECTANGLE veh_state, ST_DPOINT &amp;corners[4]) {
    double halfLength = i2d(veh_state.length)/2.0;
    double halfWidth = i2d(veh_state.width)/2.0;
    double angle = i2d(veh_state.orientation);

    // Calculate the coordinates of each corner point based on the center, length, width, and orientation
    corners[0].x = d2i(i2d(veh_state.center.x) + halfLength*cos(angle) - halfWidth*sin(angle));
    corners[0].y = d2i(i2d(veh_state.center.y) + halfLength*sin(angle) + halfWidth*cos(angle));

    corners[1].x = d2i(i2d(veh_state.center.x) + halfLength*cos(angle) + halfWidth*sin(angle));
    corners[1].y = d2i(i2d(veh_state.center.y) + halfLength*sin(angle) - halfWidth*cos(angle));

    corners[2].x = d2i(i2d(veh_state.center.x) - halfLength*cos(angle) + halfWidth*sin(angle));
    corners[2].y = d2i(i2d(veh_state.center.y) - halfLength*sin(angle) - halfWidth*cos(angle));

    corners[3].x = d2i(i2d(veh_state.center.x) - halfLength*cos(angle) - halfWidth*sin(angle));
    corners[3].y = d2i(i2d(veh_state.center.y) - halfLength*sin(angle) + halfWidth*cos(angle));
}

// Function to check if all elements in the vector (size=4) have the same sign
bool same_sign(int32_t vec[4]) {
    int i = 0;
    int sign = (vec[0] &gt;= 0) ? 1 : -1; // Get the sign of the first element
    for (i = 1; i &lt; 4; i++) {
        if ((vec[i] &gt;= 0) != (sign &gt;= 0)) {
            return false; // Different signs found
        }
    }
    return true; // All elements have the same sign
}

// check if pt1 is on the same line defined by pt2-pt3
bool check_online(ST_DPOINT pt1, ST_DPOINT pt2, ST_DPOINT pt3) {
    double dis12, dis13, dis23;

    dis12 = sqrt(pow(pt1.x - pt2.x, 2) + pow(pt1.y - pt2.y, 2));
    dis13 = sqrt(pow(pt1.x - pt3.x, 2) + pow(pt1.y - pt3.y, 2));
    dis23 = sqrt(pow(pt2.x - pt3.x, 2) + pow(pt2.y - pt3.y, 2));
    if (dis12 + dis13 == dis23)
        return true;
    else
        return false; 
}

// Check if any corner of box2 is outside box1
int check_coverage(ST_DPOINT box1[4], ST_DPOINT box2[4]) {
    int i = 0, j = 0;
    int32_t abx = 0, aby = 0, apx = 0, apy = 0;
    int32_t cross_prod[4];
    int inside_sum = 0;
    int is_online = 0;
    // Check if all corners of box2 fall outside the bounding box of box1   
    for (i = 0; i &lt; 4; i++) {
        // get the x y coordinate of the test points
        for (j = 0; j &lt; 4; j++) {
            abx = box1[(j+1)%4].x - box1[j].x; // when j+1=4, back to the first one
            aby = box1[(j+1)%4].y - box1[j].y;
            apx = box2[i].x - box1[j].x;
            apy = box2[i].y - box1[j].y;
            // cross product of ab and ap
            cross_prod[j] = abx*apy - apx*aby;
            // check if on the line
            if (check_online(box2[i], box1[j], box1[(j+1)%4]) == 1)
                is_online = 1;
        }
        // if all the cross production have the same sign, then the test point is within the box1
        if (same_sign(cross_prod) || is_online == 1)
            inside_sum++;
    }
    return inside_sum;
}

// Function to count non-zero elements in a 2D array
int check_pts_num(ST_DPOINT lane_pts[MAXP]) {
    uint16_t count = 0;
    // NONE or 0?
    while (count &lt; MAXP &amp;&amp; (lane_pts[count].x != NONE || lane_pts[count].y != NONE)){
        count++;
    }
    return count;
}

// check if veh_state are not covered by laneNet, or if vehicle rectangle touches laneNet
// can this function call check_inlane_lane_single?
bool check_inlane_laneNet(ST_RECTANGLE veh_state, int &amp;lane, ST_DPOINT &amp;veh_corners[4], ST_DPOINT &amp;box_corners[4]) {
    uint8_t i_lane = 0;
    uint8_t num_box = 0;
    uint8_t i_box = 0;
    uint8_t inlane_pts_num = 0;
    //ST_DPOINT veh_corners[4];
    //ST_DPOINT box_corners[4];

    // Calculate the corner points
    calculateCornerPoints(veh_state, veh_corners);
    for(i_lane = 0; i_lane &lt; MAXL; i_lane++){
        // check the number of points in each lane
        num_box = check_pts_num(laneNet[i_lane].left.points) - 1;
        for (i_box = 0; i_box &lt; num_box; i_box++){
            // define the corner of the road box
            box_corners[0] = laneNet[i_lane].right.points[i_box];
            box_corners[1] = laneNet[i_lane].right.points[i_box + 1];
            box_corners[2] = laneNet[i_lane].left.points[i_box + 1];
            box_corners[3] = laneNet[i_lane].left.points[i_box];
            // check if the inlane status of the vehicle box to the current box
            inlane_pts_num += check_coverage(box_corners, veh_corners);    
        }
    }
    if(inlane_pts_num &lt; 4) {
        return false;
    }
    else {
        return true;
    }
}

// check if veh_state are not covered by a single lane, or if vehicle rectangle touches the edge of the lane
bool check_inlane_lane_single(const ST_LANE lane, ST_RECTANGLE veh_state, ST_DPOINT &amp;veh_corners[4], ST_DPOINT &amp;box_corners[4]) {
    uint8_t num_box = 0;
    uint8_t i_box = 0;
    uint8_t inlane_pts_num = 0;

    //ST_DPOINT veh_corners[4];
    //ST_DPOINT box_corners[4];
    // Calculate the corner points
    calculateCornerPoints(veh_state, veh_corners);

    // check the number of points in the lane
    num_box = check_pts_num(lane.left.points) - 1;
    for (i_box = 0; i_box &lt; num_box; i_box++){
        // define the corner of the road box
        box_corners[0] = lane.right.points[i_box];
        box_corners[1] = lane.right.points[i_box + 1];
        box_corners[2] = lane.left.points[i_box + 1];
        box_corners[3] = lane.left.points[i_box];
        // check if the inlane status of the vehicle box to the current box
        inlane_pts_num += check_coverage(box_corners, veh_corners);         
    }
    
    if(inlane_pts_num &lt; 4) {
        return false;
    }
    else {
        return true;
    }
}

int32_t compute_approximating_circle_radius(int ego_length, int ego_width) {
    double length = i2d(ego_length);
    double width = i2d(ego_width);
    double square_length, diagonal_square, approx_radius;

    if (length &lt;= 0 || width &lt;= 0) {
        return -1;
    }

    if (fabs(length) &lt; 1e-6 &amp;&amp; fabs(width) &lt; 1e-6) {
        return 0;
    }
    // Divide rectangle into 3 smaller rectangles
    square_length = length/3.0;
    // Calculate minimum radius
    diagonal_square = sqrt(pow(square_length/2.0, 2) + pow(width/2.0, 2));
    // Round up value
    approx_radius = round(diagonal_square*10.0) / 10.0 + 0.1;

    return d2i(approx_radius);
}

void compute_centers_of_approximation_circles(ST_RECTANGLE veh_rect, ST_DPOINT &amp;centers[2]) {
    double disc_radius, distance_centers, veh_cent_x_double, veh_cent_y_double;

    disc_radius = i2d(compute_approximating_circle_radius(veh_rect.length, veh_rect.width));
    distance_centers = disc_radius/2.0;

    // Compute the center position of first circle (front)
    veh_cent_x_double = i2d(veh_rect.center.x);
    veh_cent_y_double = i2d(veh_rect.center.y);
    centers[0].x = d2i(veh_cent_x_double + (distance_centers/2.0)*cos(i2d(veh_rect.orientation)));
    centers[0].y = d2i(veh_cent_y_double + (distance_centers/2.0)*sin(i2d(veh_rect.orientation)));

    // Compute the center position of second circle (rear)
    centers[1].x = d2i(veh_cent_x_double - (distance_centers/2.0)*cos(i2d(veh_rect.orientation)));
    centers[1].y = d2i(veh_cent_y_double - (distance_centers/2.0)*sin(i2d(veh_rect.orientation)));
}



bool check_collision(ST_RECTANGLE veh_st_rect1, ST_RECTANGLE veh_st_rect2, int dis_thres) {    
    // define two vehicles' circle tuple (front and rear)
    ST_DPOINT veh_circle_tuple1[2] = {{0, 0}, {0, 0}};
    ST_DPOINT veh_circle_tuple2[2] = {{0, 0}, {0, 0}};
    double min_dis = FLT_MAX, dis = 0;
    int i, j;    
    //int32_t temp[2][2];
    
    // calculate the centers of the vehicles' circles
    compute_centers_of_approximation_circles(veh_st_rect1, veh_circle_tuple1);
    compute_centers_of_approximation_circles(veh_st_rect2, veh_circle_tuple2);

    for (i = 0; i &lt; 2; ++i) {
        for (j = 0; j &lt; 2; ++j) {
            dis = sqrt(pow(veh_circle_tuple1[i].x - veh_circle_tuple2[j].x, 2) + pow(veh_circle_tuple1[i].y - veh_circle_tuple2[j].y, 2));
            //temp[i][j] = d2i(dis);
            min_dis = fmin(min_dis, dis);
        }
    }
    if (dis_thres &gt; min_dis)
        return true;
    else
        return false;
}
   
</declaration>
	<template>
		<name x="5" y="5">MovingObs</name>
		<parameter>const id_t ID, const ST_CSTATE &amp;initCS, const ST_RECTANGLE &amp;shape, const ST_PAIR &amp;trajectory[MAXTP]</parameter>
		<declaration>ST_VARIABLES vars;  // continuous variables
ST_DSTATE dState;   // discrete state
uint8_t pc = 0;     // policy counter
uint8_t tc = 0;     // time counter
ST_RECTANGLE self;

void decisionMaking() {
    if(pc &lt; MAXTP &amp;&amp; tc == trajectory[pc].time) {
        // predefined trajectory starts
        vars.x = trajectory[pc].cState.position.x;
        vars.y = trajectory[pc].cState.position.y;
        vars.velocity = mTimeStep(trajectory[pc].cState.velocity);

        vars.acceleration = mTimeStep(trajectory[pc].cState.acceleration);
        vars.yawRate = mTimeStep(trajectory[pc].cState.yawRate);

        dState.acceleration = d2i(mTimeStep(trajectory[pc].cState.acceleration));
        dState.yawRate = d2i(mTimeStep(trajectory[pc].cState.yawRate));
        pc++;
    }
    else if(pc &lt; MAXTP) {
        tc++;
    }
    else if(pc &gt;= MAXTP - 1) {
        vars.velocity = 0;
        vars.acceleration = 0;
        vars.yawRate = 0;
        dState.velocity = 0;
        dState.acceleration = 0;
        dState.yawRate = 0;
    }
}

void initCon(ST_VARIABLES &amp;vars, const ST_CSTATE &amp;initCS) {
    vars.x = initCS.position.x;
    vars.y = initCS.position.y;
    vars.velocity = mTimeStep(initCS.velocity);
    vars.orientation = initCS.orientation;
    vars.acceleration = mTimeStep(initCS.acceleration);
    vars.yawRate = mTimeStep(initCS.yawRate);
    time = 0;  
}

void initDis(ST_DSTATE &amp;dState, const ST_CSTATE &amp;initCS) {
    dState.position.x = d2i(initCS.position.x);
    dState.position.y = d2i(initCS.position.y);
    dState.velocity = d2i(mTimeStep(initCS.velocity));
    dState.orientation = d2i(initCS.orientation);
    dState.acceleration = d2i(mTimeStep(initCS.acceleration));
    dState.yawRate = d2i(mTimeStep(initCS.yawRate));
}

void updateDis(ST_DSTATE &amp;dState, ST_RECTANGLE &amp;shape) {
    // real numbers of the current state
    double rVelocity = 0.0, vx = 0.0, vy = 0.0;
    double rOrientation = 0.0, rAcceleration = 0.0, rYawRate = 0.0;
    // int/real numbers of velocity on X and Y axes
    int dVx = 0, dVy = 0;
    uint8_t i = 0;
    int lane = 0;
    ST_DPOINT veh_corners[4];
    ST_DPOINT box_corners[4];

    // update discrete velocity and orientation
    dState.velocity = dState.velocity + dState.acceleration * P;
    dState.orientation = dState.orientation + dState.yawRate * P;
    // conversion to real numbers
    rVelocity = i2d(dState.velocity);
    rOrientation = i2d(dState.orientation);
    rAcceleration = i2d(dState.acceleration);
    rYawRate = i2d(dState.yawRate);
    // velocity projection
    vx = rVelocity*cos(rOrientation);
    vy = rVelocity*sin(rOrientation);
    dVx = d2i(vx);
    dVy = d2i(vy);
    // update other discrete varaibles
    dState.position.x = dState.position.x + dVx * P;
    dState.position.y = dState.position.y + dVy * P;
    shape.center.x = dState.position.x;
    shape.center.y = dState.position.y;
    shape.orientation = dState.orientation;

    dStateEgo.detection.collide |= check_collision(shapeEgo, shape, THRESHOLD);
    dState.detection.collide = dStateEgo.detection.collide;
}

void updateCon(ST_VARIABLES &amp;vars) {
    vars.acceleration = i2d(dStateEgo.acceleration);
    vars.yawRate = i2d(dStateEgo.yawRate);
}

void initialize() {
    pc = 0;
    tc = 0;
    initCon(vars,initCS);
    initDis(dState,initCS);
    self = shape;
}









</declaration>
		<location id="id0" x="-102" y="-34">
			<name x="-76" y="-34">Move</name>
			<label kind="invariant" x="-255" y="-17">vars.x' == vars.velocity*cos(vars.orientation) &amp;&amp;
vars.y' == vars.velocity*sin(vars.orientation) &amp;&amp;
vars.velocity' == vars.acceleration &amp;&amp;
vars.orientation' == vars.yawRate &amp;&amp;
vars.yawRate' == 0 &amp;&amp;
vars.acceleration' == 0</label>
		</location>
		<init ref="id0"/>
		<transition id="id1" controllable="false">
			<source ref="id0"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-161" y="-119">update?</label>
			<label kind="assignment" x="-161" y="-102">updateDis(dState,self)</label>
			<nail x="-136" y="-102"/>
			<nail x="-68" y="-102"/>
		</transition>
		<transition id="id2" controllable="false">
			<source ref="id0"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-246" y="-68">begin?</label>
			<label kind="assignment" x="-246" y="-51">initialize()</label>
			<nail x="-170" y="-68"/>
			<nail x="-170" y="-34"/>
		</transition>
		<transition id="id3" controllable="false">
			<source ref="id0"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-34" y="-68">chooseObs?</label>
			<label kind="assignment" x="-42" y="-51">decisionMaking()</label>
			<nail x="-34" y="-34"/>
			<nail x="-34" y="-68"/>
		</transition>
	</template>
	<template>
		<name>Controller</name>
		<parameter>const id_t ID, const int[0,MAXL] initLane, const ST_CSTATE &amp;initCS, const ST_RECTANGLE &amp;shape, const ST_RULES &amp;rules</parameter>
		<declaration>typedef int[0,0] BRAKE_t;    // 1 gear of brake force
typedef int[0,0] PUSH_t;     // 1 gear of push force
typedef int[0,1] TURN_t;     // 2 speeds of turning 

const int8_t Brake[3] = {d2i(-0.1), d2i(-0.2), d2i(-0.3)};
const int8_t Push[3] = {d2i(0.1), d2i(0.2), d2i(0.3)};
const int8_t Turn[2] = {d2i(0.1), d2i(-0.1)};
const bool CONSTANTSPEED = true;

void opConst() {
    dStateEgo.acceleration = 0;
    varsEgo.acceleration = 0;
}

void opAcc(int gear) {
    dStateEgo.acceleration = Push[gear];
    varsEgo.acceleration = i2d(Push[gear]);
}

void opBrake(int gear) {
    dStateEgo.acceleration = Brake[gear];
    varsEgo.acceleration = i2d(Brake[gear]);
}

void opTurn(int dir) {
    int nr = Turn[dir];
    int no = dStateEgo.orientation;
    double rVelocity = i2d(dStateEgo.velocity);
    double rOrientation = i2d(no);
    double vx = rVelocity*cos(rOrientation);
    double vy = rVelocity*sin(rOrientation);
    int nx = shapeEgo.center.x + d2i(vx) * P;
    int ny = shapeEgo.center.y + d2i(vy) * P;

    dStateEgo.yawRate = Turn[dir];
    varsEgo.yawRate = i2d(Turn[dir]);
}

void keep() {
    dStateEgo.yawRate = 0;
    varsEgo.yawRate = 0.0;
}

bool canAcc(int gear) {
    int nextAcc = Push[gear];
    if(!CONSTANTSPEED &amp;&amp; dStateEgo.velocity + P*nextAcc &lt;= rules.maxVelocity) 
        return true;
    return false;
}

bool canDec(int gear) {
    int nextDec = Brake[gear];
    if(!CONSTANTSPEED &amp;&amp; dStateEgo.velocity + P*nextDec &gt;= rules.minVelocity) 
        return true;
    return false;
}

bool canTurn(int dir) {
    int nextRate = Turn[dir];
    int nextOrientation = dStateEgo.orientation + P*nextRate;
    ST_RECTANGLE nextShape = shape;
    double rVelocity = i2d(dStateEgo.velocity);
    double rOrientation = i2d(nextOrientation);
    double vx = rVelocity*cos(rOrientation);
    double vy = rVelocity*sin(rOrientation);
    int lane = 0;
    ST_DPOINT veh_corners[4];
    ST_DPOINT box_corners[4];
    bool outroad = false;

    nextShape.center.x = shapeEgo.center.x + d2i(vx) * P;
    nextShape.center.y = shapeEgo.center.y + d2i(vy) * P;
    nextShape.orientation = nextOrientation;
    outroad = !check_inlane_laneNet(nextShape, lane, veh_corners, box_corners);

    if(nextOrientation &gt;= rules.minOrientation &amp;&amp; nextOrientation &lt;= rules.maxOrientation &amp;&amp; !outroad) 
    //if(nextOrientation &gt;= rules.minOrientation &amp;&amp; nextOrientation &lt;= rules.maxOrientation)
        return true;
    return false;
}

void updateDis(ST_DSTATE &amp;dState, ST_RECTANGLE &amp;shape) {
    // real numbers of the current state
    double rVelocity = 0.0, vx = 0.0, vy = 0.0;
    double rOrientation = 0.0, rAcceleration = 0.0, rYawRate = 0.0;
    // int/real numbers of velocity on X and Y axes
    int dVx = 0, dVy = 0;
    uint8_t i = 0;
    int lane = 0;
    ST_DPOINT veh_corners[4];
    ST_DPOINT box_corners[4];
    uint8_t inlane_pts_num = 0;

    // update discrete velocity and orientation
    dState.velocity = dState.velocity + dState.acceleration * P;
    dState.orientation = dState.orientation + dState.yawRate * P;
    // conversion to real numbers
    rVelocity = i2d(dState.velocity);
    rOrientation = i2d(dState.orientation);
    rAcceleration = i2d(dState.acceleration);
    rYawRate = i2d(dState.yawRate);
    // velocity projection
    vx = rVelocity*cos(rOrientation);
    vy = rVelocity*sin(rOrientation);
    dVx = d2i(vx);
    dVy = d2i(vy);
    // update other discrete varaibles
    dState.position.x = dState.position.x + dVx * P;
    dState.position.y = dState.position.y + dVy * P;
    shape.center.x = dState.position.x;
    shape.center.y = dState.position.y;
    shape.orientation = dState.orientation;
    dState.detection.outside = !check_inlane_laneNet(shape, lane, veh_corners, box_corners);
    dState.detection.reach = (getDisP2P(shape.center, planning.goal) &lt;= THRESHOLD);
    if(staticObsExists) {
        for(i = 0; i &lt; MAXSO; i++) {
            dState.detection.collide |= check_collision(shape, staticObs[i], THRESHOLD);
        }
    }
}

void initDis(ST_DSTATE &amp;dState) {
    ST_DPOINT leftTop = laneNet[initLane].left.points[0];
    ST_DPOINT rightTop = laneNet[initLane].left.points[1];
    ST_DPOINT rightDown = laneNet[initLane].right.points[1];
    ST_DPOINT leftDown = laneNet[initLane].right.points[0];
    ST_DPOINT middleDStart, middleDEnd;
    int16_t diffX = 0, diffY = 0;
    double xs, ys, xe, ye, angle;

    diffX = leftDown.x - leftTop.x;
    diffY = leftDown.y - leftTop.y;
    middleDStart.x = leftTop.x + diffX/2;
    middleDStart.y = leftTop.y + diffY/2;
    diffX = rightDown.x - rightTop.x;
    diffY = rightDown.y - rightTop.y;
    middleDEnd.x = rightTop.x + diffX/2;
    middleDEnd.y = rightTop.y + diffY/2;
    
    xs = i2d(middleDStart.x);
    ys = i2d(middleDStart.y);
    xe = i2d(middleDEnd.x);
    ye = i2d(middleDEnd.y);

    angle = atan2(ye-ys,xe-xs);

    if(initCS.position.x == NONE || initCS.position.y == NONE) {
        dState.position = middleDStart;
        dState.orientation = d2i(angle);
    } else {
        dState.position.x = d2i(initCS.position.x);
        dState.position.y = d2i(initCS.position.y);
        dState.orientation = d2i(initCS.orientation);
    }
    dState.acceleration = d2i(mTimeStep(initCS.acceleration));
    dState.velocity = d2i(mTimeStep(initCS.velocity));
    dState.yawRate = d2i(mTimeStep(initCS.yawRate));

    dState.detection.collide = false;
    dState.detection.outside = false;
    dState.detection.reach = false;
}

void initialize() {
    initDis(dStateEgo);
    shapeEgo = shape;
    shapeEgo.center = dStateEgo.position;
}









</declaration>
		<location id="id4" x="-340" y="-136">
			<name x="-433" y="-161">Turn_Const</name>
			<label kind="comments" x="-34" y="-51">One cannot turn and 
acc or brake 
simutaneously.</label>
		</location>
		<location id="id5" x="-68" y="136">
			<name x="-187" y="136">Straight_Dec</name>
		</location>
		<location id="id6" x="-68" y="-136">
			<name x="-51" y="-170">Straight_Acc</name>
		</location>
		<location id="id7" x="-204" y="0">
			<name x="-289" y="-17">Choose</name>
			<committed/>
		</location>
		<location id="id8" x="-340" y="136">
			<name x="-476" y="161">Straight_Const</name>
		</location>
		<init ref="id8"/>
		<transition id="id9" controllable="false">
			<source ref="id5"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="-280" y="187">begin?</label>
			<label kind="assignment" x="-195" y="187">initialize()</label>
			<nail x="-68" y="204"/>
			<nail x="-340" y="204"/>
		</transition>
		<transition id="id10" controllable="false">
			<source ref="id6"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="-424" y="-221">begin?</label>
			<label kind="assignment" x="-424" y="-204">initialize()</label>
			<nail x="-68" y="-204"/>
			<nail x="-442" y="-204"/>
			<nail x="-442" y="0"/>
		</transition>
		<transition id="id11" controllable="false">
			<source ref="id4"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="-433" y="-34">begin?</label>
			<label kind="assignment" x="-433" y="-17">initialize()</label>
			<nail x="-408" y="-136"/>
			<nail x="-408" y="0"/>
		</transition>
		<transition id="id12" controllable="false">
			<source ref="id8"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="-306" y="144">update?</label>
			<label kind="assignment" x="-306" y="161">updateDis(dStateEgo,shapeEgo)</label>
			<nail x="-331" y="170"/>
			<nail x="-306" y="170"/>
		</transition>
		<transition id="id13" controllable="false">
			<source ref="id5"/>
			<target ref="id5"/>
			<label kind="synchronisation" x="-25" y="93">update?</label>
			<label kind="assignment" x="-25" y="119">updateDis(dStateEgo,shapeEgo)</label>
			<nail x="-34" y="102"/>
			<nail x="-34" y="136"/>
		</transition>
		<transition id="id14" controllable="false">
			<source ref="id6"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="-42" y="-144">update?</label>
			<label kind="assignment" x="-42" y="-127">updateDis(dStateEgo,shapeEgo)</label>
			<nail x="-34" y="-136"/>
			<nail x="-34" y="-102"/>
		</transition>
		<transition id="id15" controllable="false">
			<source ref="id4"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-314" y="-187">update?</label>
			<label kind="assignment" x="-314" y="-170">updateDis(dStateEgo,shapeEgo)</label>
			<nail x="-306" y="-170"/>
			<nail x="-340" y="-170"/>
		</transition>
		<transition id="id16">
			<source ref="id4"/>
			<target ref="id7"/>
			<label kind="synchronisation" x="-357" y="-68">chooseEgo?</label>
			<label kind="assignment" x="-357" y="-51">keep()</label>
			<label kind="comments" x="-34" y="25">Keeps moving with 
this angle</label>
			<nail x="-340" y="-68"/>
		</transition>
		<transition id="id17" controllable="false">
			<source ref="id8"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="-467" y="102">begin?</label>
			<label kind="assignment" x="-467" y="119">initialize()</label>
			<nail x="-374" y="102"/>
			<nail x="-374" y="127"/>
		</transition>
		<transition id="id18">
			<source ref="id7"/>
			<target ref="id4"/>
			<label kind="select" x="-263" y="-93">d:TURN_t</label>
			<label kind="guard" x="-263" y="-76">canTurn(d)</label>
			<label kind="assignment" x="-263" y="-59">opTurn(d)</label>
			<nail x="-272" y="-136"/>
		</transition>
		<transition id="id19">
			<source ref="id5"/>
			<target ref="id7"/>
			<label kind="synchronisation" x="-195" y="102">chooseEgo?</label>
			<nail x="-136" y="136"/>
		</transition>
		<transition id="id20">
			<source ref="id7"/>
			<target ref="id5"/>
			<label kind="select" x="-144" y="17">f:BRAKE_t</label>
			<label kind="guard" x="-144" y="34">canDec(f)</label>
			<label kind="assignment" x="-144" y="51">opBrake(f)</label>
			<nail x="-68" y="68"/>
		</transition>
		<transition id="id21">
			<source ref="id6"/>
			<target ref="id7"/>
			<label kind="synchronisation" x="-195" y="-119">chooseEgo?</label>
			<nail x="-136" y="-136"/>
		</transition>
		<transition id="id22">
			<source ref="id7"/>
			<target ref="id6"/>
			<label kind="select" x="-136" y="-76">f:PUSH_t</label>
			<label kind="guard" x="-136" y="-59">canAcc(f)</label>
			<label kind="assignment" x="-136" y="-42">opAcc(f)</label>
			<nail x="-68" y="-68"/>
		</transition>
		<transition id="id23">
			<source ref="id7"/>
			<target ref="id8"/>
			<label kind="assignment" x="-340" y="51">opConst()</label>
			<nail x="-340" y="68"/>
		</transition>
		<transition id="id24">
			<source ref="id8"/>
			<target ref="id7"/>
			<label kind="synchronisation" x="-314" y="102">chooseEgo?</label>
			<nail x="-272" y="136"/>
		</transition>
	</template>
	<template>
		<name>Decisions</name>
		<declaration>clock timer;
int counter = 0;</declaration>
		<location id="id25" x="102" y="68">
			<name x="110" y="42">Idle</name>
			<label kind="invariant" x="85" y="85">timer&lt;=P</label>
		</location>
		<location id="id26" x="102" y="-34">
			<name x="92" y="-68">Done</name>
			<urgent/>
		</location>
		<location id="id27" x="-68" y="-34">
			<name x="-78" y="-68">ObsGo</name>
			<urgent/>
		</location>
		<location id="id28" x="-204" y="-34">
			<name x="-214" y="-68">EgoGo</name>
			<urgent/>
		</location>
		<location id="id29" x="-340" y="-34">
			<name x="-350" y="-68">Start</name>
			<urgent/>
		</location>
		<init ref="id29"/>
		<transition id="id30" controllable="false">
			<source ref="id25"/>
			<target ref="id28"/>
			<label kind="guard" x="-348" y="51">counter==MAXTIME</label>
			<label kind="synchronisation" x="-348" y="68">begin!</label>
			<label kind="assignment" x="-348" y="85">timer=0,counter=0</label>
			<nail x="68" y="102"/>
			<nail x="-340" y="102"/>
			<nail x="-340" y="0"/>
		</transition>
		<transition id="id31" controllable="false">
			<source ref="id29"/>
			<target ref="id28"/>
			<label kind="synchronisation" x="-280" y="-59">begin!</label>
		</transition>
		<transition id="id32" controllable="false">
			<source ref="id25"/>
			<target ref="id28"/>
			<label kind="guard" x="-170" y="0">timer==P&amp;&amp;
counter!=MAXTIME</label>
			<label kind="synchronisation" x="-170" y="42">update!</label>
			<label kind="assignment" x="-102" y="42">timer=0,counter++</label>
			<nail x="-204" y="68"/>
		</transition>
		<transition id="id33" controllable="false">
			<source ref="id26"/>
			<target ref="id25"/>
			<label kind="assignment" x="59" y="-8">timer=0</label>
		</transition>
		<transition id="id34" controllable="false">
			<source ref="id27"/>
			<target ref="id26"/>
			<label kind="synchronisation" x="-34" y="-59">chooseObs!</label>
		</transition>
		<transition id="id35" controllable="false">
			<source ref="id28"/>
			<target ref="id27"/>
			<label kind="synchronisation" x="-170" y="-59">chooseEgo!</label>
		</transition>
	</template>
	<template>
		<name>Dynamics</name>
		<parameter>const id_t ID, const int[0,MAXL] initLane, const ST_CSTATE &amp;initCS</parameter>
		<declaration>void initCon(ST_VARIABLES &amp;vars) {
    ST_DPOINT leftTop = laneNet[initLane].left.points[0];
    ST_DPOINT rightTop = laneNet[initLane].left.points[1];
    ST_DPOINT rightDown = laneNet[initLane].right.points[1];
    ST_DPOINT leftDown = laneNet[initLane].right.points[0];
    ST_DPOINT middleDStart, middleDEnd;
    int16_t diffX = 0, diffY = 0;
    double xs, ys, xe, ye, angle;

    diffX = leftDown.x - leftTop.x;
    diffY = leftDown.y - leftTop.y;
    middleDStart.x = leftTop.x + diffX/2;
    middleDStart.y = leftTop.y + diffY/2;
    diffX = rightDown.x - rightTop.x;
    diffY = rightDown.y - rightTop.y;
    middleDEnd.x = rightTop.x + diffX/2;
    middleDEnd.y = rightTop.y + diffY/2;
    
    xs = i2d(middleDStart.x);
    ys = i2d(middleDStart.y);
    xe = i2d(middleDEnd.x);
    ye = i2d(middleDEnd.y);

    angle = atan2(ye-ys,xe-xs);

    if(initCS.position.x == NONE || initCS.position.y == NONE) {
        vars.x = i2d(middleDStart.x);
        vars.y = i2d(middleDStart.y);
        vars.orientation = angle;
    } else {
        vars.x = initCS.position.x;
        vars.y = initCS.position.y;
        vars.orientation = initCS.orientation;
    }
    vars.velocity = mTimeStep(initCS.velocity);
    vars.acceleration = mTimeStep(initCS.acceleration);
    vars.yawRate = mTimeStep(initCS.yawRate);

    time = 0;
    if(dStateEgo.detection.reach) 
        D = 0; // only reset the reward function when reaching the goal
    if(dStateEgo.detection.collide || dStateEgo.detection.outside)
        D = D + 100; // punish the ego when it collides or goes outside the road    
}

void updateCon(ST_VARIABLES &amp;vars) {
    vars.acceleration = i2d(dStateEgo.acceleration);
    vars.yawRate = i2d(dStateEgo.yawRate);
}</declaration>
		<location id="id36" x="0" y="0">
			<name x="-59" y="-8">Move</name>
			<label kind="invariant" x="-161" y="17">varsEgo.x' == varsEgo.velocity*cos(varsEgo.orientation) &amp;&amp;
varsEgo.y' == varsEgo.velocity*sin(varsEgo.orientation) &amp;&amp;
varsEgo.velocity' == varsEgo.acceleration &amp;&amp;
varsEgo.orientation' == varsEgo.yawRate &amp;&amp;
varsEgo.yawRate' == 0 &amp;&amp;
varsEgo.acceleration' == 0 &amp;&amp;
D' == getDisP2P(dStateEgo.position, planning.goal) 
      - dStateEgo.detection.reach * 100 
      + dStateEgo.detection.collide * 50 
      + dStateEgo.detection.outside * 50</label>
		</location>
		<init ref="id36"/>
		<transition id="id37" controllable="false">
			<source ref="id36"/>
			<target ref="id36"/>
			<label kind="synchronisation" x="68" y="-68">update?</label>
			<label kind="assignment" x="68" y="-51">updateCon(varsEgo)</label>
			<nail x="68" y="-68"/>
			<nail x="68" y="-34"/>
		</transition>
		<transition id="id38" controllable="false">
			<source ref="id36"/>
			<target ref="id36"/>
			<label kind="synchronisation" x="-161" y="-68">begin?</label>
			<label kind="assignment" x="-161" y="-51">initCon(varsEgo)</label>
			<nail x="-68" y="-34"/>
			<nail x="-68" y="-68"/>
		</transition>
	</template>
	<system>// Generated moving obstacles starts

// Generated moving obstacles ends

// position, velocity, orientation, acceleration, yawRate
const ST_CSTATE initEgo = {{NONE, NONE}, 30.0, 0.0, 0.0, 0.0}; 
const ST_RECTANGLE initShapeEgo = {{NONE, NONE}, 100, 450, 0};
const ST_RULES rules = {4000, 0, 314, -314}; 
const int[0,MAXL] initLane = 0;
egoController = Controller(1, initLane, initEgo, initShapeEgo, rules);
egoDynamics = Dynamics(1, initLane, initEgo);

// Generated model instances start
system Decisions, egoController, egoDynamics;

// Generated model instances end
</system>
	<queries>
		<option key="--total-runs" value="50"/>
		<option key="--max-iterations" value="3"/>
		<option key="--good-runs" value="20"/>
		<option key="--eval-runs" value="10"/>
		<option key="--runs-pr-state" value="10"/>
		<option key="--diagnostic" value="0"/>
		<query>
			<formula>E&lt;&gt; dStateEgo.detection.reach</formula>
			<comment/>
		</query>
		<query>
			<formula>E[] !dStateEgo.detection.collide &amp;&amp; !dStateEgo.detection.outside</formula>
			<comment/>
		</query>
		<query>
			<formula>strategy safe = control:A[] !dStateEgo.detection.collide &amp;&amp; !dStateEgo.detection.outside
</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-05-17 10:01:34 +0200">
				<option key="--total-runs" value="50"/>
				<option key="--max-iterations" value="3"/>
				<option key="--good-runs" value="20"/>
				<option key="--eval-runs" value="10"/>
				<option key="--runs-pr-state" value="10"/>
				<option key="--diagnostic" value="0"/>
			</result>
		</query>
		<query>
			<formula>strategy reachSafe = minE(D) [&lt;=MAXTIME] {egoController.location}-&gt;{dStateEgo.position.x, dStateEgo.position.y, dStateEgo.velocity, dStateEgo.orientation, dStateEgo.acceleration, dStateEgo.yawRate}: &lt;&gt; time&gt;=MAXTIME under safe</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-05-17 10:01:38 +0200">
				<option key="--total-runs" value="50"/>
				<option key="--max-iterations" value="3"/>
				<option key="--good-runs" value="20"/>
				<option key="--eval-runs" value="10"/>
				<option key="--runs-pr-state" value="10"/>
				<option key="--diagnostic" value="0"/>
			</result>
		</query>
		<query>
			<formula>simulate [&lt;=MAXTIME] { varsEgo.x, varsEgo.y, varsEgo.orientation, varsEgo.velocity, varsEgo.acceleration } under reachSafe</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-05-17 10:01:41 +0200">
				<option key="--total-runs" value="50"/>
				<option key="--max-iterations" value="3"/>
				<option key="--good-runs" value="20"/>
				<option key="--eval-runs" value="10"/>
				<option key="--runs-pr-state" value="10"/>
				<option key="--diagnostic" value="0"/>
				<plot title="Simulations (1)" xaxis="time" yaxis="value">
					<series title="varsEgo.x" type="l" color="0xff0000" encoding="csv">0.0,0.0
10.000002,30.000006
					</series>
					<series title="varsEgo.y" type="l" color="0xccff00" encoding="csv">0.0,0.0
10.000002,0.0
					</series>
					<series title="varsEgo.orientation" type="l" color="0x00ff66" encoding="csv">0.0,0.0
10.000002,0.0
					</series>
					<series title="varsEgo.velocity" type="l" color="0x0066ff" encoding="csv">0.0,0.0
0.0,3.0
10.000002,3.0
					</series>
					<series title="varsEgo.acceleration" type="l" color="0xcc00ff" encoding="csv">0.0,0.0
10.000002,0.0
					</series>
					<comment/>
				</plot>
			</result>
		</query>
	</queries>
</nta>
